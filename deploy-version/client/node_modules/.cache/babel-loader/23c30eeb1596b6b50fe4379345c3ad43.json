{"ast":null,"code":"import _slicedToArray from\"C:/Users/Ahmed Saad/Desktop/final-text-editor/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";/*The main reason we choose quill is the delta feature \r\nthat allows multiple users to edit at the same time without overwriting any changes */ // here is all the code for our text editor component\n// Q- Quill isn't a react component so we need to do some work\nimport React,{useEffect,useCallback,useState}from'react';import Quill from\"quill\";import\"quill/dist/quill.snow.css\";// stylesheet\nimport{io}from'socket.io-client';// to allow connections \nimport{useParams}from'react-router-dom';// route to different routes \nimport{jsx as _jsx}from\"react/jsx-runtime\";var editor2=document.createElement(\"div\");var ENDPOINT=' https://text-editor-project.herokuapp.com/';var SAVE_INTERVAL_MS=2000;// every 2 seconds we are saving our document \nexport default function TextEdtior(){/* State allows us to manage changing data in an application. so we create \r\na state for socket and a state for quill to access it from anywhere (in the code) \r\nso now we can sync between users (collaboration)\r\n-- useState Hook allows us to track state in a function component*/var _useParams=useParams(),documentId=_useParams.id;var _useState=useState(),_useState2=_slicedToArray(_useState,2),socket=_useState2[0],setSocket=_useState2[1];var _useState3=useState(),_useState4=_slicedToArray(_useState3,2),quill=_useState4[0],setQuill=_useState4[1];var _useState5=useState(1),_useState6=_slicedToArray(_useState5,2),user=_useState6[0],setUser=_useState6[1];// useEffect? you tell React that your component needs to do something after render(aka display)\n//-------------------loading document----------------------\nuseEffect(function(){if(socket==null||quill==null)return;// we have to make sure they are defined because this func depends on them\n// once automatically cleans up the event after \nsocket.once(\"load-document\",function(document){quill.setContents(document.data);quill.enable();//we enable only if we get document \n});socket.emit(\"get-document\",documentId);// send to server document ID\n},[socket,quill,documentId]);// once we load the document we get the number of users of the document and display it\nuseEffect(function(){if(socket==null||quill==null)return;socket.once(\"load-document\",function(document){quill.setContents(document.data);quill.enable();editor2.innerHTML=\"Number of Current Users \"+document.user;});},[socket,quill]);/* we want to establish the connection once([]) upon rendering so we use a \r\nuseEffect to handle this connection*/ //-------------------handling connection-----------------------\nuseEffect(function(){var s=io(ENDPOINT);// url of server // this function returns a socket(state)\nsetSocket(s);return function(){s.disconnect();//cleaning up \n};},[]);//------------------saving our document ----------------------\nuseEffect(function(){if(socket==null||quill==null)return;/* interval creates a timer*/var interval=setInterval(function(){socket.emit(\"save-document\",quill.getContents());},SAVE_INTERVAL_MS);//save our contents every 2 seconds \nreturn function(){clearInterval(interval);//cleaning up \n};},[socket,quill]);// this func depends on socket,quill\n//-------------------updating our document---------------------\nuseEffect(function(){if(socket==null||quill==null)return;var handler=function handler(delta){quill.updateContents(delta);};socket.on('receive-changes',handler);return function(){quill.off('receive-changes',handler);};},[socket,quill]);// this func depends on socket,quill\n// we listen on the number of users of the document and display it\nuseEffect(function(){if(socket==null)return;socket.on('users',function(user){setUser(user);editor2.innerHTML=\"Number of Current Users \"+user;});},[socket,user]);// this func depends on socket,user\n//------------------listening to changes -------------------\nuseEffect(function(){if(socket==null||quill==null)return;var handler=function handler(delta,oldDelta,source){// we do this because we are only interested in the changes the user makes we do not want\n// any changes done in the library (not by the user to be sent to the clients)\nif(source!=='user')return;socket.emit(\"send-changes\",delta);// is just what changed in the document -- we send this to the server using socket.emit\n};quill.on('text-change',handler);// text-change quill API, handler is called whenever text-change is on\nreturn function(){quill.off('text-change',handler);// upon cleaning up \n};},[socket,quill]);// this func depends on socket,quill\n// we have our useCallback function that is gonna be called once the wrapper is rendered on our page\n// it takes the wrapper as parameter so wrapper is always defined before useCallback is called\nvar wrapperRef=useCallback(function(wrapper){if(wrapper==null)return;wrapper.innerHTML=\"\";// clean up --> every time we call this we want to set html to an empty string and to not allow to create mulitple toolbars\nvar editor=document.createElement(\"div\");//create an object editor\nwrapper.append(editor2);// put editor into wrapper \nwrapper.append(editor);// put editor into wrapper \neditor2.innerHTML=\"Number of Current Users \";/*so when quill is created \r\nit is included in the main container including everything and changes \r\ndon't cause replication of objects because we used a wrapper and since everything \r\nis placed in a container we can clean it up each time using wrapper.innerHtml=\"\" */var q=new Quill(editor,{theme:\"snow\"});q.disable();// if no document then disbale \nq.setText('Loading...');// if disabled display Loading...\nsetQuill(q);},[]);return/*#__PURE__*/_jsx(\"div\",{className:\"text\",ref:wrapperRef});}/* we're creating an instance of the quill component once after rendering the page*/ /* we use ref to reference our container and then UseRef to allow access DOM elements directly, and persist data \r\nbetween renders without causing a component to re-render infinitely when changes occur (so we avoid)\r\nrerendering the quill component or toolbar when page is refreshed or changes are made*/","map":{"version":3,"names":["React","useEffect","useCallback","useState","Quill","io","useParams","editor2","document","createElement","ENDPOINT","SAVE_INTERVAL_MS","TextEdtior","documentId","id","socket","setSocket","quill","setQuill","user","setUser","once","setContents","data","enable","emit","innerHTML","s","disconnect","interval","setInterval","getContents","clearInterval","handler","delta","updateContents","on","off","oldDelta","source","wrapperRef","wrapper","editor","append","q","theme","disable","setText"],"sources":["C:/Users/Ahmed Saad/Desktop/final-text-editor/client/src/TextEdtior.js"],"sourcesContent":["/*The main reason we choose quill is the delta feature \r\nthat allows multiple users to edit at the same time without overwriting any changes */\r\n// here is all the code for our text editor component\r\n// Q- Quill isn't a react component so we need to do some work\r\nimport React, { useEffect,useCallback,useState } from 'react'\r\nimport Quill from \"quill\"\r\nimport \"quill/dist/quill.snow.css\" // stylesheet\r\nimport {io} from 'socket.io-client' // to allow connections \r\nimport {useParams} from 'react-router-dom'  // route to different routes \r\nconst editor2=document.createElement(\"div\") \r\nconst ENDPOINT = ' https://text-editor-project.herokuapp.com/';\r\n\r\n\r\nconst SAVE_INTERVAL_MS = 2000 // every 2 seconds we are saving our document \r\nexport default function TextEdtior() {\r\n\r\n/* State allows us to manage changing data in an application. so we create \r\na state for socket and a state for quill to access it from anywhere (in the code) \r\nso now we can sync between users (collaboration)\r\n-- useState Hook allows us to track state in a function component*/\r\n\r\n    const {id: documentId}=useParams()\r\n    const [socket,setSocket]=useState()\r\n    const [quill,setQuill]=useState()\r\n    const [user,setUser]=useState(1)\r\n\r\n// useEffect? you tell React that your component needs to do something after render(aka display)\r\n//-------------------loading document----------------------\r\nuseEffect (()=>{\r\n    if(socket== null || quill==null) return // we have to make sure they are defined because this func depends on them\r\n// once automatically cleans up the event after \r\n    socket.once (\"load-document\",document =>{\r\n        quill.setContents (document.data)\r\n        quill.enable() //we enable only if we get document \r\n    })\r\n  socket.emit (\"get-document\",documentId) // send to server document ID\r\n  },[socket,quill,documentId])\r\n\r\n// once we load the document we get the number of users of the document and display it\r\n  useEffect (()=>{\r\n    if(socket== null || quill==null) return\r\n    socket.once (\"load-document\",document =>{\r\n        quill.setContents (document.data)\r\n        quill.enable()\r\n        editor2.innerHTML=\"Number of Current Users \"+document.user\r\n\r\n    })\r\n  },[socket,quill])\r\n\r\n/* we want to establish the connection once([]) upon rendering so we use a \r\nuseEffect to handle this connection*/\r\n//-------------------handling connection-----------------------\r\n\r\n    useEffect(() => {\r\n       const s= io(ENDPOINT)  // url of server // this function returns a socket(state)\r\n       setSocket(s)\r\n        return () => {\r\n         s.disconnect()  //cleaning up \r\n        }\r\n    },[])\r\n\r\n//------------------saving our document ----------------------\r\n      useEffect(() => {\r\n    if (socket == null || quill == null) return\r\n/* interval creates a timer*/\r\n    const interval = setInterval(() => {\r\n      socket.emit(\"save-document\", quill.getContents())\r\n    }, SAVE_INTERVAL_MS) //save our contents every 2 seconds \r\n\r\n    return () => {\r\n      clearInterval(interval) //cleaning up \r\n    }\r\n  }, [socket, quill]) // this func depends on socket,quill\r\n\r\n //-------------------updating our document---------------------\r\n    useEffect(()=> {\r\n        if(socket== null || quill==null) return\r\n\r\n        const handler = (delta)=>{\r\n          \r\n            quill.updateContents(delta)\r\n        }\r\n        socket.on('receive-changes',handler)\r\n\r\n\r\n        return () => {\r\n            quill.off('receive-changes',handler)\r\n        }\r\n    },[socket,quill]) // this func depends on socket,quill\r\n\r\n// we listen on the number of users of the document and display it\r\n    useEffect(()=> {\r\n      if(socket== null) return\r\n      socket.on('users',user => {\r\n        setUser(user)\r\n        editor2.innerHTML=\"Number of Current Users \"+user\r\n\r\n      })\r\n  },[socket,user]) // this func depends on socket,user\r\n\r\n    //------------------listening to changes -------------------\r\n    useEffect(()=> {\r\n        if(socket== null || quill==null) return\r\n\r\n        const handler = (delta,oldDelta,source)=>{\r\n// we do this because we are only interested in the changes the user makes we do not want\r\n// any changes done in the library (not by the user to be sent to the clients)\r\n            if (source!== 'user') return\r\n            socket.emit(\"send-changes\",delta) // is just what changed in the document -- we send this to the server using socket.emit\r\n        }\r\n        quill.on('text-change',handler)  // text-change quill API, handler is called whenever text-change is on\r\n\r\n        return () => {\r\n            quill.off('text-change',handler)  // upon cleaning up \r\n        }\r\n    },[socket,quill]) // this func depends on socket,quill\r\n    \r\n// we have our useCallback function that is gonna be called once the wrapper is rendered on our page\r\n// it takes the wrapper as parameter so wrapper is always defined before useCallback is called\r\n   const wrapperRef= useCallback((wrapper) => {\r\n        if (wrapper==null) return\r\n\r\n       wrapper.innerHTML=\"\" // clean up --> every time we call this we want to set html to an empty string and to not allow to create mulitple toolbars\r\n       const editor=document.createElement(\"div\") //create an object editor\r\n       wrapper.append(editor2) // put editor into wrapper \r\n\r\n       wrapper.append(editor) // put editor into wrapper \r\n       editor2.innerHTML=\"Number of Current Users \"\r\n/*so when quill is created \r\nit is included in the main container including everything and changes \r\ndon't cause replication of objects because we used a wrapper and since everything \r\nis placed in a container we can clean it up each time using wrapper.innerHtml=\"\" */       \r\n        const q=new Quill(editor,{theme: \"snow\"})\r\n        q.disable()  // if no document then disbale \r\n        q.setText('Loading...') // if disabled display Loading...\r\n        setQuill(q)\r\n    } ,[])\r\n\r\n\r\n  return <div className=\"text\" ref={wrapperRef}></div>\r\n  \r\n}\r\n/* we're creating an instance of the quill component once after rendering the page*/\r\n/* we use ref to reference our container and then UseRef to allow access DOM elements directly, and persist data \r\nbetween renders without causing a component to re-render infinitely when changes occur (so we avoid)\r\nrerendering the quill component or toolbar when page is refreshed or changes are made*/"],"mappings":"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"},"metadata":{},"sourceType":"module"}